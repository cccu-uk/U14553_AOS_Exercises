<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>System Calls - AOS Exercises</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Labs</li><li class="chapter-item expanded "><a href="../Multi-ThreadedScripting-ProcessManagement/Multi-ThreadedScripting-ProcessManagement.html"><strong aria-hidden="true">2.</strong> Multi-Threaded Scripting & Process Management</a></li><li class="chapter-item expanded "><a href="../Learning_C/Learning_C.html"><strong aria-hidden="true">3.</strong> Learning C</a></li><li class="chapter-item expanded "><a href="../SystemCalls/SystemCalls.html" class="active"><strong aria-hidden="true">4.</strong> System Calls</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> System Statistics Script</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> RFC Logger Script</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Man page Example</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Scheduling</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Daemons</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Shell Stuff</li><li class="chapter-item expanded "><a href="../Shell/shell.html"><strong aria-hidden="true">10.</strong> Shell</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Shell/installation.html"><strong aria-hidden="true">10.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../Shell/introducing_shell.html"><strong aria-hidden="true">10.2.</strong> Introducing the Shell</a></li><li class="chapter-item expanded "><a href="../Shell/fileDir.html"><strong aria-hidden="true">10.3.</strong> Navigating File and Directories</a></li><li class="chapter-item expanded "><a href="../Shell/create.html"><strong aria-hidden="true">10.4.</strong> Working with FIles and Directories</a></li><li class="chapter-item expanded "><a href="../Shell/pipefilter.html"><strong aria-hidden="true">10.5.</strong> Pipes and Filters</a></li><li class="chapter-item expanded "><a href="../Shell/loops.html"><strong aria-hidden="true">10.6.</strong> Loop</a></li><li class="chapter-item expanded "><a href="../Shell/scripts.html"><strong aria-hidden="true">10.7.</strong> Scripts</a></li><li class="chapter-item expanded "><a href="../Shell/find.html"><strong aria-hidden="true">10.8.</strong> Finding Things</a></li><li class="chapter-item expanded "><a href="../Shell/reference.html"><strong aria-hidden="true">10.9.</strong> Summary of Basic Commands</a></li></ol></li><li class="chapter-item expanded "><a href="../Shell_Extras/introduction.html"><strong aria-hidden="true">11.</strong> Extra Shell</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Shell_Extras/manfiles.html"><strong aria-hidden="true">11.1.</strong> Manual Pages</a></li><li class="chapter-item expanded "><a href="../Shell_Extras/workremote.html"><strong aria-hidden="true">11.2.</strong> Working Remotely</a></li><li class="chapter-item expanded "><a href="../Shell_Extras/permissions.html"><strong aria-hidden="true">11.3.</strong> Permissions</a></li><li class="chapter-item expanded "><a href="../Shell_Extras/dirstruct.html"><strong aria-hidden="true">11.4.</strong> Working with Files and Directories</a></li><li class="chapter-item expanded "><a href="../Shell_Extras/jobs.html"><strong aria-hidden="true">11.5.</strong> Job Control</a></li><li class="chapter-item expanded "><a href="../Shell_Extras/aliases.html"><strong aria-hidden="true">11.6.</strong> Aliases and bash customisation</a></li><li class="chapter-item expanded "><a href="../Shell_Extras/shellvars.html"><strong aria-hidden="true">11.7.</strong> Shell Variables</a></li><li class="chapter-item expanded "><a href="../Shell_Extras/references.html"><strong aria-hidden="true">11.8.</strong> Summary of Commands</a></li></ol></li><li class="chapter-item expanded "><a href="../Shell_Style_Guide/shellstyleguide.html"><strong aria-hidden="true">12.</strong> Shell Style Guide</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Git</li><li class="chapter-item expanded "><a href="../myFirstRepository/myFirstRepository.html"><strong aria-hidden="true">13.</strong> My First Repository</a></li><li class="chapter-item expanded "><a href="../BranchingModel/BranchingModel.html"><strong aria-hidden="true">14.</strong> Branching-Strategy</a></li><li class="chapter-item expanded "><a href="../OneFlow/OneFlow.html"><strong aria-hidden="true">15.</strong> Git Oneflow</a></li><li class="chapter-item expanded "><a href="../AntiPatterns/AntiPatterns.html"><strong aria-hidden="true">16.</strong> Anti Patterns</a></li><li class="chapter-item expanded "><a href="../ContinousDeployment/ContinousDeployment.html"><strong aria-hidden="true">17.</strong> Continous Deployment</a></li><li class="chapter-item expanded "><a href="../ReleaseDeployment/ReleaseDeployment.html"><strong aria-hidden="true">18.</strong> Release Deployment</a></li><li class="chapter-item expanded "><a href="../Migration/Migration.html"><strong aria-hidden="true">19.</strong> Migration</a></li><li class="chapter-item expanded affix "><li class="part-title">Operating Systems/ Virtual Machines</li><li class="chapter-item expanded "><a href="../OS/Introduction.html"><strong aria-hidden="true">20.</strong> OS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../OS/nixOS/nixOS.html"><strong aria-hidden="true">20.1.</strong> NixOS</a></li><li class="chapter-item expanded "><a href="../OS/arch/arch.html"><strong aria-hidden="true">20.2.</strong> Arch</a></li><li class="chapter-item expanded "><a href="../OS/RPIOS/rpios.html"><strong aria-hidden="true">20.3.</strong> Raspberry Pi OS</a></li><li class="chapter-item expanded "><a href="../OS/WindowsCoreIoT/WindowsCoreIoT.html"><strong aria-hidden="true">20.4.</strong> Windows Core IoT</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">AOS Exercises</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/cccu-uk/U14553_AOS_Exercises/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cccu-uk/U14553_AOS_Exercises/edit/master/src/SystemCalls/SystemCalls.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="system-calls"><a class="header" href="#system-calls">System Calls</a></h1>
<p>In this Lab you are going to use <code>shell</code> commands and write some programs in <code>c</code> to understand the concepts of system calls. </p>
<blockquote>
<p><strong>Note:</strong></p>
<blockquote>
<p>You are to use JupyterHub or any other linux system with the <code>gcc</code> compiler installed.
Prerequistes: <a href="../Learning_C/Learning_C.html">Learning C</a></p>
</blockquote>
</blockquote>
<h2 id="task-1---excelp"><a class="header" href="#task-1---excelp">Task 1 - <code>excelp()</code></a></h2>
<ol>
<li>
<p>Open a terminal.</p>
</li>
<li>
<p>change directory to <code>NOS/Learning_C/</code></p>
<ul>
<li><code>$ cd NOS/Learning_C</code></li>
</ul>
</li>
<li>
<p>make a directory called SystemCalls and change direcory </p>
<ul>
<li><code>$ mkdir SystemCalls &amp;&amp; cd SystemCalls</code></li>
</ul>
</li>
<li>
<p>Now create a file called <code>my_ps.c</code></p>
<ul>
<li><code>$ nano my_ps.c</code></li>
</ul>
</li>
</ol>
<p>Reproduce the following code: </p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
  printf(&quot;ps with execlp\n&quot;);
  execlp(&quot;ps&quot;, &quot;ps&quot;, 0); //if error do NULL instead of 0 
  printf(&quot;Done.\n&quot;);
  exit(0);
}

</code></pre>
<p>Once entered use the keyboard shortcut to <code>writeout</code> <kbd>ctrl</kbd>+<kbd>o</kbd> and then press the <kbd>Enter</kbd> followed by <kbd>ctrl</kbd>+<kbd>x</kbd> to exit the file.</p>
<p>Now you need to compile the code:</p>
<pre><code class="language-sh">$ gcc my_ps.c -o my_ps
</code></pre>
<p>Now, you can run it: </p>
<pre><code class="language-sh">$ ./my_ps
</code></pre>
<p>Output: </p>
<pre><code class="language-sh">ps with execlp
  PID TTY          TIME CMD
12377 pts/0    00:00:00 bash
18304 pts/0    00:00:00 ps
</code></pre>
<p>When you run it, you get the usual <code>ps</code> output without &quot;Done.&quot; message at all. Also, there is no reference to a process called <code>my_ps</code> in the output.</p>
<p>The code prints the first message, <code>ps with execlp</code>, and then calls <code>execlp()</code>, which searches the directories given by the <code>PATH</code> environmet variable for a program called <code>ps</code>. It then executes <code>ps</code> in place of <code>my_ps</code>, starting it as if you had issued the shell command:</p>
<pre><code class="language-sh">$ ps
</code></pre>
<p>So, when <code>ps</code> finishes, you get a new shell prompt. You don't return to <code>my_ps</code>. Thus, the second message, &quot;Done.&quot;, doesn't get printed. The <code>PID</code> of the new process is the same as the original, as are the parent <code>PID</code> and <code>nice</code> value.</p>
<p>To use processes to perform more than one function at a time, you can either use threads or create an extirely separate process from within a program, as <code>init</code> does, rather than replace the current thread of execution, <code>exec</code>, as shown in the above example.</p>
<h2 id="task-12---fork-with-execv"><a class="header" href="#task-12---fork-with-execv">Task 1.2 - <code>fork()</code> with <code>execv()</code></a></h2>
<p>In the following code, <code>fork()</code> on parent process creates child process, and then the child itself run <code>execv()</code> to replace the parent code with a new code specified in the path.</p>
<p>Create a new file called <code>fork_execv.c</code></p>
<pre><code class="language-sh">$ nano fork_execv.c
</code></pre>
<p>Reprodce the code:</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


void main(char *path, char *argv[]) 
{ 
    int pid = fork(); 
    if (pid == 0) 
    { 
        printf(&quot;Child\n&quot;); 
        execv(path, argv); 
    } 
    else 
    { 
        printf(&quot;Parent %d\n&quot;, pid); 
    } 
    printf(&quot;Parent prints this line \n&quot;); 
} 
</code></pre>
<p>Again <code>writeout</code> and compile:</p>
<pre><code class="language-sh">$ gcc fork_execv.c -o fork_execv
</code></pre>
<p>Run it:</p>
<pre><code class="language-sh">$ ./fork_execv
</code></pre>
<p>Output: </p>
<pre><code class="language-sh">Parent 105
Parent prints this line 
Child
Parent prints this line
</code></pre>
<h2 id="task-2-fork-in-depth"><a class="header" href="#task-2-fork-in-depth">Task 2: <code>fork()</code> in depth</a></h2>
<p>System call <code>fork()</code> takes <strong>no</strong> arguments and returns a process ID. The purpose of <code>fork()</code> is to create a new process, which becomes the child process of the caller. After a new child process is created, both processes will execute the next instruction following the <code>fork()</code> system call. Therefore, you have to distinguish the parent from the child. This can be done by testing the returned value of <code>fork()</code>:</p>
<ol>
<li>
<p>returns a negative value, the creation of a child process was unsuccessful.</p>
</li>
<li>
<p>returns a zero to the newly created child process.</p>
</li>
<li>
<p>returns a positive value, the process ID of the child process, to the parent. The returned process ID is of type <code>pid_t</code> defined in <code>sys/types.h</code>. Normally, the process ID is an <code>int</code>. Moreover, a process can use function <code>getpid()</code> to retrieve the process ID assigned to this process.</p>
</li>
</ol>
<p>Create a new file called, <code>fork_indepth.c</code></p>
<pre><code class="language-sh">$ nano fork_indepth.c
</code></pre>
<p>Now reproduce the following code:</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define BUF_SIZE 150

int main()
{
  int pid = fork();
  char buf[BUF_SIZE];
  int print_count;

  switch (pid)
  {
    case -1:
      perror(&quot;fork failed&quot;);
      exit(1);
    case 0:
      /* When fork() returns 0, you are in the child process. */
      print_count = 10;
      sprintf(buf,&quot;child process: pid = %d&quot;, pid);
      break;
    default: /* + */
      /* When fork() returns a positive number, you are in the parent process
       * (the fork return value is the PID of the newly created child process) */
      print_count = 5;
      sprintf(buf,&quot;parent process: pid = %d&quot;, pid);
      break;
  }
  for(;print_count &gt; 0; print_count--) {
      puts(buf);
      sleep(1);
  }
  exit(0);
}
</code></pre>
<p>Compile and run:</p>
<pre><code class="language-sh">$ gcc fork_indepth.c -o fork_indepth
$ ./fork_indepth
</code></pre>
<p>Output:</p>
<pre><code class="language-sh">parent process: pid = 165
child process: pid = 0
parent process: pid = 165
child process: pid = 0
parent process: pid = 165
child process: pid = 0
parent process: pid = 165
child process: pid = 0
parent process: pid = 165
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
</code></pre>
<p>As you can see from the output, the call to <code>fork()</code> in the parent returns the <code>PID</code> of the new child process. The new process continues to execute just like the old, with the exception that in the child process the call to <code>fork()</code> returns 0.</p>
<p>When you start a child process with <code>fork()</code>, it runs independently. But sometimes, you want to find out when a child process has finished. If the parent finishes ahead of the child, as the case in the example above, you may get confused, and it may not what you want to happen. So, you need to arrange for the parent process to wait until the child finishes by calling <code>wait()</code>.</p>
<h2 id="task-3-fork-and-wait"><a class="header" href="#task-3-fork-and-wait">Task 3: <code>fork</code> and <code>wait()</code></a></h2>
<p>The execution of <code>wait()</code> could have two possible situations.</p>
<ol>
<li>
<p>If there are at least one child processes running when the call to <code>wait()</code> is made, the caller will be blocked until one of its child processes exits. At that moment, the caller resumes its execution.</p>
</li>
<li>
<p>If there is no child process running when the call to <code>wait()</code> is made, then this <code>wait()</code> has no effect at all. That is, it is as if no <code>wait()</code> is there.</p>
</li>
</ol>
<p>The <code>wait(&amp;status)</code> system call has two purposes.</p>
<ol>
<li>
<p>If a child of this process has not yet terminated by calling <code>exit()</code>, then <code>wait()</code> suspends execution of the process until one of its children has terminated.</p>
</li>
<li>
<p>The termination status of the child is returned in the status argument of <code>wait()</code>.</p>
</li>
</ol>
<p>Open a new file called <code>fork_n_wait.c</code></p>
<pre><code class="language-sh">$ nano fork_n_wait.c
</code></pre>
<p>The code you need to reproduce is very similar to the previous script, but with <code>wait()</code> implemented.</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define BUF_SIZE 150

int main()
{
  int pid = fork();
  char buf[BUF_SIZE];
  int print_count;

  switch (pid)
  {
    case -1:
      perror(&quot;fork failed&quot;);
      exit(1);
    case 0:
      print_count = 10;
      sprintf(buf,&quot;child process: pid = %d&quot;, pid);
      break;
    default:
      print_count = 5;
      sprintf(buf,&quot;parent process: pid = %d&quot;, pid);
      break;
  }
  if(!pid) {
    int status;
    int pid_child = wait(&amp;status);
  }
  for(;print_count &gt; 0; print_count--) puts(buf);
  exit(0);
}
</code></pre>
<p>Again you need to compile:</p>
<pre><code class="language-sh">$ gcc fork_n_wait.c -o fork_n_wait
</code></pre>
<p>Ignore the following message if you see it: </p>
<pre><code class="language-sh">fork_n_wait.c: In function ‘main’:
fork_n_wait.c:30:21: warning: implicit declaration of function ‘wait’ [-Wimplicit-function-declaration]
   30 |     int pid_child = wait(&amp;status);
      |           
</code></pre>
<p>Now run and you should a different output to previous script.</p>
<pre><code class="language-sh">$ ./fork_n_wait
</code></pre>
<p>Output:</p>
<pre><code>parent process: pid = 191
parent process: pid = 191
parent process: pid = 191
parent process: pid = 191
parent process: pid = 191
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
</code></pre>
<p>The parent process is now using the <code>wait()</code> system call to suspend its own execution by checking the return value from the call.</p>
<h2 id="task-4---day-z"><a class="header" href="#task-4---day-z">Task 4 - Day-Z</a></h2>
<p>Zombie processes don’t use up any system resources. (Actually, each one uses a very tiny amount of system memory to store its process descriptor.) However, each zombie process retains its process ID (PID). </p>
<p>Linux systems have a finite number of process IDs — 32767 by default on 32-bit systems. </p>
<p>If zombies are accumulating at a very quick rate — for example, if improperly programmed server software is creating zombie processes under load — the entire pool of available PIDs will eventually become assigned to zombie processes, preventing other processes from launching.</p>
<p>However, a few zombie processes hanging around are no problem — although they do indicate a bug with their parent process on your system.</p>
<p>Create a new script called <code>zombie.c</code></p>
<pre><code class="language-sh">$ nano zombie.c
</code></pre>
<p>Reproduce the following code:</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define BUF_SIZE 150

int main()
{
  int pid = fork();
  char buf[BUF_SIZE];
  int print_count;

  switch (pid)
  {
    case -1:
      perror(&quot;fork failed&quot;);
      exit(1);
    case 0:
      print_count = 2;
      sprintf(buf,&quot;child process: pid = %d&quot;, pid);
      break;
    default:
      print_count = 4;
      sprintf(buf,&quot;parent process: pid = %d&quot;, pid);
      break;
  }
  for(;print_count &gt; 0; print_count--) {
      puts(buf);
      system(&quot;ps -la | grep zombie | grep -v grep&quot;); 
      sleep(1);
  }
  exit(0);
}
</code></pre>
<p>Compile the code:</p>
<pre><code class="language-sh">$ gcc zombie.c -o zombie
</code></pre>
<p>If you run the code above, the child process will finish its task ahead of parent process, and will exist as a zombie until the parent finishes as shown in the output below:</p>
<pre><code class="language-sh">$ ./zombie
</code></pre>
<p>Output: </p>
<pre><code class="language-sh">parent process: pid = 404
child process: pid = 0
0 S  1000   403    54  0  80   0 -   691 do_wai pts/0    00:00:00 zombie
1 S  1000   404   403  0  80   0 -   691 do_wai pts/0    00:00:00 zombie
0 S  1000   403    54  0  80   0 -   691 hrtime pts/0    00:00:00 zombie
1 S  1000   404   403  0  80   0 -   691 do_wai pts/0    00:00:00 zombie
parent process: pid = 404
child process: pid = 0
0 S  1000   403    54  0  80   0 -   691 do_wai pts/0    00:00:00 zombie
1 D  1000   404   403  0  80   0 -   700 do_for pts/0    00:00:00 zombie
1 R  1000   417   404  0  80   0 -   700 -      pts/0    00:00:00 zombie
0 S  1000   403    54  0  80   0 -   691 do_wai pts/0    00:00:00 zombie
1 S  1000   404   403  0  80   0 -   691 do_wai pts/0    00:00:00 zombie
parent process: pid = 404
0 S  1000   403    54  0  80   0 -   691 do_wai pts/0    00:00:00 zombie
1 Z  1000   404   403  0  80   0 -     0 -      pts/0    00:00:00 zombie &lt;defunct&gt;
parent process: pid = 404
0 S  1000   403    54  0  80   0 -   691 do_wai pts/0    00:00:00 zombie
1 Z  1000   404   403  0  80   0 -     0 -      pts/0    00:00:00 zombie &lt;defunct&gt;
</code></pre>
<p>You can't kill zombie processes as you can kill normal processes with the <code>SIGKILL</code> signal - zombie processes are already dead. Regarding zombies, UNIX systems imitate the movies - a zombie process can't be killed by a signal, not even the (silver bullet) <code>SIGKILL</code>. Actually, this was the intentional feature to ensure that the parent can always eventually perform a <code>wait()</code>. Bear in mind that you don't need to get rid of zombie processes unless you have a large amount on our system - a few zombies are harmless. However, there are a few ways we can get rid of zombie processes.</p>
<p>One way is by sending the <code>SIGCHLD</code> signal to the parent process. This signal tells the parent process to execute the <code>wait()</code> system call and clean up its zombie children. Send the signal with the <code>kill</code> command, replacing <code>pid</code> in the command below with the parent process's <code>PID</code>:</p>
<pre><code class="language-sh">kill -s SIGCHLD pid
</code></pre>
<p>However, if the parent process isn't programmed properly and is ignoring <code>SIGCHLD</code> signals, this won't help. You'll have to kill or close the zombies' parent process. When the process that created the zombies ends, <code>init</code> inherits the zombie processes and becomes their new parent. (<code>init</code> is the first process started on Linux at boot and is assigned PID <code>1</code>.) <code>init</code> periodically executes the <code>wait()</code> system call to clean up its zombie children, so <code>init</code> will make short work of the zombies. You can restart the parent process after closing it.</p>
<p>If a parent process continues to create zombies, it should be fixed so that it properly calls <code>wait()</code> to reap its zombie children.</p>
<p>A <strong>zombie</strong> process is not the same as an <strong>orphan</strong> process. An <strong>orphan</strong> process is a process that is still executing, but whose parent has died. They do not become zombie processes; instead, they are adopted by <code>init</code> (process ID <code>1</code>)</p>
<p>In other words, after a child's parent terminates, a call to <code>getppid()</code> will return the value <code>1</code>. This can be used as a way of determining if a child's true parent is still alive (this assumes a child that was created by a process other than <code>init</code>).</p>
<h2 id="task-5---signals"><a class="header" href="#task-5---signals">Task 5 - Signals</a></h2>
<p>When you type the interrupt character (<code>Ctrl</code>+<code>c</code>), the <code>ISGINT</code> signal will be sent to the foreground process (the program currently running). This will cause the program to terminate unless it has some arrangement for catching the signal.</p>
<p>The command <code>kill</code> can be used to send a signal to a process other than the current foreground process. To send a hangup signal to a shell running on a different terminal, you can use the following command:</p>
<pre><code class="language-sh">$ kill -HUP pid_number
</code></pre>
<p>There is another useful variant of <code>kill</code> is <code>killall</code>. This allows us to send a signal to all processes running a specified command. For example, to send a reread signal to the <code>inetd</code> program:</p>
<pre><code class="language-sh">$ killall -HUP inetd
</code></pre>
<p>The command causes the <code>inetd</code> program to reread its configuration options.</p>
<p>In the following example, the program will reacts to the <code>ctrl+c</code> rather than terminating foreground task. But if you hit the <code>ctrl+c</code> again, it will do what it usually does, terminating the program.</p>
<p>Create a new file called <code>signals.c</code></p>
<pre><code class="language-sh">nano signals.c
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;

void my_signal_interrupt(int sig)
{
  printf(&quot;I got signal %d\n&quot;, sig);
  (void) signal(SIGINT, SIG_DFL);
}

int main()
{
  (void) signal(SIGINT,my_signal_interrupt);

  while(1) {
      printf(&quot;Waiting for interruption...\n&quot;);
      sleep(1);
  }
}
</code></pre>
<p>Compile and run:</p>
<pre><code class="language-sh">gcc signals.c -o signals &amp;&amp; ./signals
</code></pre>
<p>Remember to press <code>ctrl</code>+<code>c</code> to interact and do it a second time to close the program.</p>
<p>Output:</p>
<pre><code class="language-sh">/signals
Waiting for interruption...
Waiting for interruption...
Waiting for interruption...
Waiting for interruption...
Waiting for interruption...
Waiting for interruption...
Waiting for interruption...
Waiting for interruption...
I got signal 2
Waiting for interruption...
Waiting for interruption...
Waiting for interruption...
Waiting for interruption...

</code></pre>
<p>The <code>my_signal_interrupt()</code> is called when we give <code>SIGINT</code> signal by typing <code>ctrl+C</code>. After the interrupt function <code>my_signal_interrupt()</code> has completed, the program moves on, but the signal action is restored to the default. So, when it gets a second <code>SIGINT</code> signal, the program takes the default action, which is terminating the program.</p>
<h2 id="signals-look-up"><a class="header" href="#signals-look-up">Signals Look up</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Signal</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>SIGHUP</code></td><td>1</td><td>Hangup (POSIX)</td></tr>
<tr><td><code>SIGINT</code></td><td>2</td><td>Terminal interrupt (ANSI)</td></tr>
<tr><td><code>SIGQUIT</code></td><td>3</td><td>Terminal quit (POSIX)</td></tr>
<tr><td><code>SIGILL</code></td><td>4</td><td>Illegal instruction (ANSI)</td></tr>
<tr><td><code>SIGTRAP</code></td><td>5</td><td>Trace trap (POSIX)</td></tr>
<tr><td><code>SIGIOT</code></td><td>6</td><td>IOT Trap (4.2 BSD)</td></tr>
<tr><td><code>SIGBUS</code></td><td>7</td><td>BUS error (4.2 BSD)</td></tr>
<tr><td><code>SIGFPE</code></td><td>8</td><td>Floating point exception (ANSI)</td></tr>
<tr><td><code>SIGKILL</code></td><td>9</td><td>Kill(can't be caught or ignored) (POSIX)</td></tr>
<tr><td><code>SIGUSR1</code></td><td>10</td><td>User defined signal 1 (POSIX)</td></tr>
<tr><td><code>SIGSEGV</code></td><td>11</td><td>Invalid memory segment access (ANSI)</td></tr>
<tr><td><code>SIGUSR2</code></td><td>12</td><td>User defined signal 2 (POSIX)</td></tr>
<tr><td><code>SIGPIPE</code></td><td>13</td><td>Write on a pipe with no reader, Broken pipe (POSIX)</td></tr>
<tr><td><code>SIGALRM</code></td><td>14</td><td>Alarm clock (POSIX)</td></tr>
<tr><td><code>SIGTERM</code></td><td>15</td><td>Termination (ANSI)</td></tr>
<tr><td><code>SIGSTKFLT</code></td><td>16</td><td>Stack fault</td></tr>
<tr><td><code>SIGCHLD</code></td><td>17</td><td>Child process has stopped or exited, changed (POSIX)</td></tr>
<tr><td><code>SIGCONT</code></td><td>18</td><td>Continue executing, if stopped (POSIX)</td></tr>
<tr><td><code>SIGSTOP</code></td><td>19</td><td>Stop executing(can't be caught or ignored) (POSIX)</td></tr>
<tr><td><code>SIGTSTP</code></td><td>20</td><td>Terminal stop signal (POSIX)</td></tr>
<tr><td><code>SIGTTIN</code></td><td>21</td><td>Background process trying to read, from TTY (POSIX)</td></tr>
<tr><td><code>SIGTTOU</code></td><td>22</td><td>Background process trying to write, to TTY (POSIX)</td></tr>
<tr><td><code>SIGURG</code></td><td>23</td><td>Urgent condition on socket (4.2 BSD)</td></tr>
<tr><td><code>SIGXCPU</code></td><td>24</td><td>CPU limit exceeded (4.2 BSD)</td></tr>
<tr><td><code>SIGXFSZ</code></td><td>25</td><td>File size limit exceeded (4.2 BSD)</td></tr>
<tr><td><code>SIGVTALRM</code></td><td>26</td><td>Virtual alarm clock (4.2 BSD)</td></tr>
<tr><td><code>SIGPROF</code></td><td>27</td><td>Profiling alarm clock (4.2 BSD)</td></tr>
<tr><td><code>SIGWINCH</code></td><td>28</td><td>Window size change (4.3 BSD, Sun)</td></tr>
<tr><td><code>SIGIO</code></td><td>29</td><td>I/O now possible (4.2 BSD)</td></tr>
<tr><td><code>SIGPWR</code></td><td>30</td><td>Power failure restart (System V)</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Learning_C/Learning_C.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../Shell/shell.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Learning_C/Learning_C.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../Shell/shell.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
